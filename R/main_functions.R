#' Plot legend of cellular organelles
#'
#' @description This function plots the legend of cellular organelles.
#' @param dt_legend A \code{data.table} with the polygon coordinates to be
#'   plotted in the legend figure.
#' @return A ggplot object with the legend of labeled organelles.
#'
#' @import ggplot2
#'
plot_legend_organelles <- function(dt_legend){

    text_labels <- data.table(names=unique(dt_legend$subcell_struct),
                              x = max(dt_legend$x)+10,
                              y = (dt_legend[, max(.SD[, y]), by=subcell_struct]$V1 +
                                       dt_legend[, min(.SD[, y]), by=subcell_struct]$V1)/2)

    text_labels <- text_labels[, names := stringr::str_replace(names, "\\_", "\n")]

    bs=25
    p <- ggplot(dt_legend, aes(x, y, color=comb)) +
        scale_color_manual(values = rep("black", length(dt_legend[, first(subcell_struct), by=comb]$V1))) +
        geom_polygon(fill=NA) +
        annotate("text",
                 x=text_labels$x,
                 y=text_labels$y,
                 label=text_labels$names,
                 hjust = 0,
                 size=0.2*bs) +
        coord_cartesian(xlim = c(90,400)) +
        scale_y_reverse() +
        theme_void() +
        theme(legend.position = "none")
    return(p)
}

#' Plot outline of a cellular pictograph.
#'
#' @description This function plots the outline of the selected cell type. A \code{data.table}
#' containing all the graphical information to draw the chosen cell type must be
#' specified through the \code{dt_name} parameter. The \code{data.tables} to create various
#' cell types are provided within the package and the plots can be generated by
#' chosen the desired data structure (\code{pictograph="cell"}, or \code{pictograph="neuron"}).
#' A ggplot object with default colors for the specified cell is then given as output.
#' @param dt_name A \code{data.table} with the polygon coordinates to be
#'   plotted.
#' @param legend A boolean value for choosing to plot the legend or not.
#' @return a ggplot object with the cell figure with default colors.
#' @examples plot_cell(dt_name="neuron")
#'
#' @import ggplot2
#'
#' @export
plot_cell <- function(dt_name, legend=TRUE){

    if (all(dt_name == "cell")){
        coords_dt <- cell_dt
        w <- c(3,1)
    } else {
        if (all(dt_name == "neuron")) {
                coords_dt <- neuron_dt
                w <- c(4,1)
        } else {
            if (all(dt_name == "fibroblast")) {
                coords_dt <- fibroblast_dt
                w <- c(3,1)
            } else {
                if (all(dt_name == "microglia")) {
                    coords_dt <- microglia_dt
                    w <- c(2,1)
                } else {
                    if (all(dt_name == "lymphocyte")) {
                        coords_dt <- lymphocyte_dt
                        w <- c(2,1)
                    } else {
                        if (all(dt_name == "macrophage")){
                            coords_dt <- macrophage_dt
                            w <- c(2,1)
                        } else {
                            stop("No available pictograph with this name")
                        }
                    }
                }
            }
        }
    }

    ecmx <- min(coords_dt[subcell_struct == "extracellular_region"]$x) + (max(coords_dt[subcell_struct == "extracellular_region"]$x)-
                 min(coords_dt[subcell_struct == "extracellular_region"]$x))/1.5

    ecmy <- (min(coords_dt[subcell_struct == "extracellular_region"]$y)+
                 max(coords_dt[subcell_struct == "extracellular_region"]$y))/3

    bs=25
    p <- ggplot(coords_dt, aes(x, y, fill=comb, color=comb)) +
        scale_fill_manual(values = coords_dt[, first(color), by=comb]$V1) +
        scale_color_manual(values = rep("black", length(coords_dt[, first(color), by=comb]$V1))) +
        geom_polygon() +
        annotate("text", x=ecmx, y=ecmy, label="ECM", size=bs*0.2, angle=90) +

        scale_y_reverse() +
        theme_void() +
        theme(legend.position = "none")

    if (dt_name == "lymphocyte"){
        p <- p +
            annotate("text", x=530, y=150, label="pseudopodium", size=bs*0.2) +
            geom_segment(aes(x=480, y=150, xend=440, yend=140))
    }

    if (dt_name == "macrophage"){
        p <- p +
            annotate("text", x=800, y=550, label="pseudopodium", size=bs*0.2) +
            geom_segment(aes(x=760, y=550, xend=740, yend=480))
    }

    if (legend==TRUE){
        l <- plot_legend_organelles(dt_legend=legend_dt)
        p <- ggpubr::ggarrange(p, l, widths = w)
    }

    return(p)
}

#' Plot available cellular pictographs
#' @description This function plots the outline of the all the availables cell type.
#' @examples available_pictographs()
#'
#' @import ggplot2
#' @import patchwork
#' @import stringr
#'
#' @export
available_pictographs <- function() {
    p_list <- list()
    pictographs <- c("cell","microglia", "fibroblast",  "macrophage", "neuron","lymphocyte")
    for (d in pictographs){
        p_list[[d]] <- plot_cell(d, legend = FALSE) +
            ggtitle(stringr::str_to_title(d)) +
            coord_fixed()
    }

    patchwork::wrap_plots(p_list) + plot_layout(ncol = 2, nrow = 3)
}

#' Create table for mapping genes to subcellular localization
#'
#' @description This function generates the \code{data.table} necessary to
#'   associate genes to a subcellular localization.
#' @param gene_set A character vector with the gtf file path with
#'   the genome annotation.
#' @param  organism A character vector with the name of the organism-specific
#'   gene annotation term for each gene. Available organisms are: "Homo.sapiens" or "Hs",
#'   "Mus.musculus" or "Mm",
#'   "Rattus.norvegicus" or "Rn"
#'   "Danio.rerio" or "Dr",
#'   "Saccharomyces.cerevisiae" or "Sc".
#' @return A \code{data.table} with the gene ontology subcellular localization.
#'
#' @import data.table
#' @import DOSE
#' @import clusterProfiler
#' @import rtracklayer
#' @import stringr
#' @import BiocManager
#'
#' @details A gene annotatation file, in GTF format is required as input. On
#'   this complete set of gene symbols, a gene ontology enrichment analysis is
#'   performed to associate a gene with a term in the cellular component
#'   ontology. For this purpose, only the sub-ontology of the cellular
#'   components is taken into consideration. This step generates the
#'   gene-localization \code{data.table}, which maps each gene to the locations in the
#'   cellular structures, either cellular compartments or macromolecular
#'   complexes.
#'
#' @export
#'
#'
map_gene_localization <- function(gene_set, organism){

    if (is.null(organism)){
        stop("Organism information is missing")
    }


    if (organism=="Homo.sapiens" | organism=="Hs"){
        check_dep <- require("org.Hs.eg.db")

        if (!check_dep){
            BiocManager::install("org.Hs.eg.db")
            require("org.Hs.eg.db")
        }

        OrgDb_chosen="org.Hs.eg.db"
    }

    if (organism=="Mus.musculus" | organism=="Mm"){

        check_dep <- require("org.Mm.eg.db")

        if (!check_dep){
            BiocManager::install("org.Mm.eg.db")
            require("org.Mm.eg.db")
        }
        OrgDb_chosen="org.Mm.eg.db"
    }

    if (organism=="Rattus.norvegicus" | organism=="Rn"){
        check_dep <- require("org.Rn.eg.db")

        if (!check_dep){
            BiocManager::install("org.Rn.eg.db")
            BiocManager::available("org.Rn.eg.db")
        }
        OrgDb_chosen="org.Rn.eg.db"
    }

    if (organism=="Danio.rerio" | organism=="Dr"){
        check_dep <- require("org.Dr.eg.db")

        if (!check_dep){
            BiocManager::install("org.Dr.eg.db")
            require("org.Dr.eg.db")
        }
        OrgDb_chosen="org.Dr.eg.db"
    }

    if (organism=="Saccharomyces.cerevisiae" | organism=="Sc"){
        check_dep <- require("org.Sc.sgd.db")

        if (!check_dep){
            BiocManager::install("org.Sc.sgd.db")
            require("org.Sc.sgd.db")
        }
        OrgDb_chosen="org.Sc.sgd.db"
    }

    if (is.character(gene_set)){
        gtf <- rtracklayer::import(gene_set)

        annotation_gene_names <- unique(gtf$gene_name)
    }

    # else {
    #     if (inherits(gene_set, "list")){
    #         annotation_gene_names <- unique(unlist(lapply(gene_set, function(x) x[, "gene_symbol"])))
    #     } else {
    #         stop("Unrecognized input")
    #     }
    # }

    ensembl_entrez <- bitr(annotation_gene_names, fromType="SYMBOL", toType=c("ENTREZID"), OrgDb=OrgDb_chosen, drop=T)

    entrez <- mapIds(get(OrgDb_chosen), annotation_gene_names, 'ENTREZID', 'SYMBOL')

    cc_complete <- as.data.table(as.data.frame(enrichGO(gene = ensembl_entrez[,2],
                                                        OrgDb=OrgDb_chosen,
                                                        ont = "CC",
                                                        pvalueCutoff = 1,
                                                        pAdjustMethod = "none",
                                                        qvalueCutoff = 1,
                                                        minGSSize = 1,
                                                        maxGSSize = length(ensembl_entrez$ENTREZID),
                                                        readable = T)))

    cc_complete_dt <- cc_complete[, .(geneID = unlist(tstrsplit(geneID, "\\/", type.convert = TRUE))), by = c("ID", "Description")]
    cc_complete_dt <- cc_complete_dt[, Description := stringr::str_replace(Description, "\\ ", "\\_")]
    setnames(cc_complete_dt, old = c("geneID", "Description"), new=c("gene_symbol", "subcell_struct"))
    return(cc_complete_dt)
}

#' Compute discrete and symmetric ranges
#'
#' @description This function creates a table with ranges for mapping values with associated colors and labels.
#' @param timepoint_list A list of \code{data.table}s, one for each time point. Each one must have at least a column
#'   named "gene_symbol".
#' @param plot_data A \code{data.table} with the polygon coordinates to be plotted.
#' @param gene_loc_table A \code{data.table} with information for mapping genes to subcellular localizations.
#' @param col_name A character string with the name of the column on which the user wants to base the color of cellular
#'   localizations when "median" or "mean" are the chosen coloring method.
#' @param grouping_vars A character vector with classes of genes to be considered.
#' @param colors A character vector with two color codes for generating a color palettes with a shade for each interval.
#' @param coloring_mode Either "mean" or "median". Default is "mean".
#'
#'   A name of a numerical columns must also be provided as \code{col_name} parameter. This method computes the mean (or
#'   median) of values specified in the \code{col_name} column.
#' @param together A boolean value specifying whether genes with different classification labels should be considered
#'   together (regardless their classification) or separately.
#' @return A list of \code{data.table}s (one for each categorical variable value specified in the \code{grouping_vars}
#'   parameter) with categorical classes into which the numerical values (previously grouped for each subcellular
#'   localization) are mapped.
#'
#' @import data.table
#'
discrete_symmetric_ranges <- function(timepoint_list,
                                      plot_data,
                                      gene_loc_table,
                                      col_name,
                                      grouping_vars,
                                      colors,
                                      coloring_mode,
                                      together=FALSE){

    dtlist <- list()

    if (together){
        # one unique data.table with ranges is created
        # ordered in increasing order by value

        groupedval <-  c()
        for (tp in names(timepoint_list)){

            if (!is.null(grouping_vars)){


                tmp <- data.table::data.table(gene_symbol=character(),
                                              x=character(),
                                              y=numeric())

                setnames(tmp, old=c("x", "y"), new = c(names(grouping_vars), col_name))

                for (c in unlist(grouping_vars)){
                    genes <- timepoint_list[[tp]][get(names(grouping_vars)) == c,
                                                  c("gene_symbol", names(grouping_vars), col_name),
                                                  with=FALSE]
                    tmp <- funion(tmp, genes)
                }

                genes <- tmp

            } else {
                genes <- timepoint_list[[tp]]
            }


            groupedval <- c(groupedval,
                            groupval_byloc(genes = genes,
                                           plot_data,
                                           gene_loc_table,
                                           col_name,
                                           coloring_mode))
        }

        sup <- ceiling(max(groupedval, na.rm = TRUE))
        inf <- floor(min(groupedval, na.rm = TRUE))

        width <- abs(sup - inf)

        if (width <= 8){

            if(width == 1){
                fixed_ranges_dt <- data.table(start = head(seq(inf, sup, by = 0.1), -1),
                                              end = seq(inf, sup, by = 0.1)[-1])
            } else {
                fixed_ranges_dt <- data.table(start = head(seq(inf, sup), -1),
                                              end = seq(inf, sup)[-1])
            }
        } else {
            binsize <- width / 8

            sizes <- c(1, 1.5, 2, 5, 10, 15, 20, 25, 50, 100, 200, 500, 1000, 2000)
            diff <- sizes - binsize

            binsize <- sizes[which(diff == min(diff[diff > 0]))]
            sup <- sup + binsize
            new_inf <- round(inf/10) * 10

            if (new_inf > inf){
                inf = 0
            } else {
                inf = new_inf
            }

            fixed_ranges_dt <- data.table(start = head(seq(inf, sup, by = binsize), -1),
                                          end = seq(inf, sup, by = binsize)[-1])

        }

        if (!all(fixed_ranges_dt$start>=0)){
            # I am plotting down and up together in the same plot
            # and I need to remove zero ranges and have two color scales, green and red
            fixed_ranges_dt_o <- copy(fixed_ranges_dt)

            zeros_dt <- fixed_ranges_dt[apply(fixed_ranges_dt, 1, function(row) any(row == 0 ))]
            zeros_dt <- rbind(zeros_dt, data.table(start = min(zeros_dt$start), end = max(zeros_dt$end)))

            fixed_ranges_dt <- fixed_ranges_dt[apply(fixed_ranges_dt, 1, function(row) all(row !=0 )), ]
            pos <- fixed_ranges_dt[start > 0]
            neg <- fixed_ranges_dt[start < 0]
            zeros_dt <- zeros_dt[apply(zeros_dt, 1, function(row) all(row !=0 )), ]

            if (is.null(colors)){
                color_codes <- sample_colors(2)

                colfunc <- colorRampPalette(c("white", color_codes[[1]]))
                colors_vector <- colfunc(n = 1+(nrow(pos)-1)*3+1)[-1]
                colors_vector <- colors_vector[seq(1, length(colors_vector), len=nrow(pos))]
                pos <- pos[, colors := colors_vector]

                colfunc <- colorRampPalette(c(color_codes[[2]], "white"))
                colors_vector <- rev(colfunc(n = 1+(nrow(neg)-1)*3+1))[-1]
                colors_vector <- colors_vector[seq(1, length(colors_vector), len=nrow(neg))]
                neg <- neg[, colors := colors_vector]
            } else {

                # if ((nrow(pos)>0 & nrow(neg)==0) | (nrow(pos)==0 & nrow(neg)>0)){
                #     colors[which(colors=="white")] <- "lightblue"
                # }

                if (nrow(fixed_ranges_dt) == 0){
                    # if only two existing ranges, one positive and one negative, and the user has
                    # provided colors, the pair of colors is assigned to the fixed_dt

                    # colors can be a list with color shades for each grouping vars
                    # and in this case only the final shade is selected

                    if (is.list(colors)){

                        colors_red <- sapply(colors, function(x) x[1])

                        fixed_ranges_dt <- fixed_ranges_dt_o[, values := seq(1, nrow(fixed_ranges_dt_o))
                        ][, lab := paste("<", .SD[, round(end, 2)]), by=values]

                        neg <- fixed_ranges_dt[start < 0][, colors := colors_red[1]]
                        pos <- fixed_ranges_dt[start >= 0][, colors := colors_red[2]]

                        fixed_ranges_dt <- rbind(neg, pos)


                    } else {
                        fixed_ranges_dt <- fixed_ranges_dt_o[, values := seq(1, nrow(fixed_ranges_dt_o))
                        ][, lab := paste("<", .SD[, round(end, 2)]), by=values
                        ][, colors := colors]
                    }
                } else {
                    dt_list <- list()
                    if (nrow(pos)>0) {
                        colfunc <- colorRampPalette(colors[[1]])
                        colors_vector <- colfunc(n = 1+(nrow(pos)-1)*3+1)[-1]
                        colors_vector <- colors_vector[seq(1, length(colors_vector), len=nrow(pos))]
                        pos <- pos[, colors := colors_vector]
                        dt_list[["pos"]] <- pos
                    }

                    if (nrow(neg)>0) {
                        colfunc <- colorRampPalette(colors[[2]])
                        colors_vector <- rev(colfunc(n = 1+(nrow(neg)-1)*3+1))[-1]
                        colors_vector <- colors_vector[seq(1, length(colors_vector), len=nrow(neg))]
                        neg <- neg[, colors := colors_vector]
                        dt_list[["neg"]] <- neg
                    }

                    zeros_dt <- zeros_dt[, colors := "white"]
                    dt_list[["zeros"]] <- zeros_dt

                    fixed_ranges_dt <- rbindlist(dt_list)

                    fixed_ranges_dt <- fixed_ranges_dt[order(start)]

                    fixed_ranges_dt[, values := seq(1, nrow(fixed_ranges_dt))
                    ][, lab := paste("<", .SD[, round(end, 2)]), by=values
                    ][colors == "white", lab := "= 0"]

                }
            }
        } else {
            # all the values are of the same sign, so I am plotting CPM cols or FC but all for the same sign
            colfunc <- colorRampPalette(colors)
            colors_vector <- colfunc(n = (nrow(fixed_ranges_dt)-1)*3+1)
            colors_vector <- colors_vector[seq(1, length(colors_vector), len=nrow(fixed_ranges_dt))]
            fixed_ranges_dt <- fixed_ranges_dt[, colors := colors_vector]
            fixed_ranges_dt[, values := seq(1, nrow(fixed_ranges_dt))
            ][, lab := paste("<", .SD[, round(end, 2)]), by=values]
        }

        dtlist <- fixed_ranges_dt

    } else {
        max_v <- min_v <- widths <- c()
        for (c in unlist(grouping_vars)){
            groupedval <-  c()
            for (tp in names(timepoint_list)){

                genes <- timepoint_list[[tp]][get(names(grouping_vars)) == c]

                if (nrow(genes) !=0) {
                    groupedval <- c(groupedval,
                                    groupval_byloc(genes = genes,
                                                   plot_data,
                                                   gene_loc_table,
                                                   col_name,
                                                   coloring_mode))
                }
            }

            if (!is.null(groupedval)){
                max_v[[c]] <- ceiling(max(abs(groupedval), na.rm = TRUE))
                min_v[[c]] <- floor(min(abs(groupedval), na.rm = TRUE))

                widths[[c]] <- abs(max_v[[c]]-min_v[[c]])
            }
        }

        max_range_width <- which(widths == max(unlist(widths)))

        if (max(unlist(widths)) <= 8){

            if (max(unlist(widths)) <= 1) {

                inf <- unlist(min_v[max_range_width])
                sup <- unlist(max_v[max_range_width])

                if (length(inf) > 1) {
                    inf <- inf[[1]]
                }

                if (length(sup) > 1) {
                    sup <- sup[[1]]
                }

                fixed_ranges_dt <- data.table(start = head(seq(inf, sup, by = 0.2), -1),
                                              end = seq(inf, sup, by = 0.2)[-1])

            } else {

                inf <- unlist(min_v[max_range_width])
                sup <- unlist(max_v[max_range_width])

                if (length(inf) > 1) {
                    inf <- inf[[1]]
                }

                if (length(sup) > 1) {
                    sup <- sup[[1]]
                }

                fixed_ranges_dt <- data.table(start = head(seq(inf, sup), -1),
                                              end = seq(inf, sup)[-1])
            }

        } else {
            w <- max(unlist(widths))
            binsize <- w / 8

            sizes <- c(1, 1.5, 2, 5, 10, 20, 25, 50, 100, 200, 500, 1000, 2000)
            diff <- sizes - binsize

            binsize <- sizes[which(diff == min(diff[diff >0]))]

            inf <- unlist(min_v[max_range_width])
            sup <- w + inf


            fixed_ranges_dt <- data.table(start = head(seq(inf, sup, by = binsize), -1),
                                          end = seq(inf, sup, by = binsize)[-1])
        }

        if (length(widths) > length(colors)){
            stop("Check that colors and grouping vars parameters match.")
        }

        for (c in names(widths)){
            #cat(c)
            colfunc <- colorRampPalette(colors[[c]])

            fixed_ranges_dt <- copy(fixed_ranges_dt)
            fixed_ranges_dt <- fixed_ranges_dt[, values := seq(1, nrow(fixed_ranges_dt))
            ][, lab := paste("<", .SD[, round(end, 2)]), by=values]

            colors_vector <- colfunc(n = (nrow(fixed_ranges_dt)-1)*3+1)
            colors_vector <- colors_vector[seq(1, length(colors_vector), len=nrow(fixed_ranges_dt))]
            fixed_ranges_dt <- fixed_ranges_dt[, colors := colors_vector]

            dtlist[[c]] <- fixed_ranges_dt[, eval(names(grouping_vars)) := c]
        }

        dtlist <- rbindlist(dtlist)

    }

    return(dtlist)

}

#' Compute mean (or median) of values associated to genes for each cellular
#' compartment
#'
#' @param genes A \code{data.table} of gene names with associated log fold
#'   change values. Columns must be named "gene_symbol" and "logFC".
#' @param plot_data A \code{data.table} with the polygon coordinates to be
#'   plotted.
#' @param gene_loc_table A \code{data.table} with information for mapping genes
#'   to subcellular localizations.
#' @param col_name A character string with the name of the column on which the
#'   user wants to base the color of cellular localizations when "median" or
#'   "mean" are the chosen coloring method.
#' @param coloring_mode Either "mean" or "median". Default is "mean".
#'
#' A name of a numerical columns must also be provided as \code{col_name}
#' parameter. This method computes the mean (or median) of values specified in
#' the \code{col_name} column.
#'
#' @return The sampled color code.
#'
#' @import data.table
#'
groupval_byloc <- function(genes, plot_data, gene_loc_table, col_name, coloring_mode="mean"){

    gene_loc_table <- gene_loc_table[subcell_struct %in% unique(plot_data$subcell_struct)]

    genes_sel <- data.table::merge.data.table(genes,
                                              gene_loc_table[, c("gene_symbol", "subcell_struct")],
                                              by = "gene_symbol")
    if (nrow(genes_sel) == 0){

        stop("Check gene_symbol column in timepoint_list, maybe you gave me the wrong format of gene symbols?")
    }


    if (coloring_mode == "mean"){
        localization_values <- genes_sel[, .(mean(as.numeric(get(col_name)), na.rm = TRUE)), by=subcell_struct]
        localization_values <- localization_values[order(abs(V1), decreasing = TRUE)]
        setnames(localization_values, old="V1", new=eval(coloring_mode))
    } else {
        if (coloring_mode == "median"){
            localization_values <- genes_sel[, .(median(get(col_name), na.rm = TRUE)), by=subcell_struct]
            localization_values <- localization_values[order(abs(V1), decreasing = TRUE)]
            setnames(localization_values, old="V1", new=eval(coloring_mode))
        } else {
            cat("Unrecognized parameter, assigned default coloring_mode=\"mean\"")
        }
    }

    return(localization_values[, get(coloring_mode)])

}


#' Sample random colors
#'
#' @param n An integer specifying the number of random color to sample
#'
#' @import RColorBrewer
#'
sample_colors <- function(n){
    qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
    col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
    col=sample(col_vector, n)
    return(col)
}

